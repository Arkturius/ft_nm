void	nm64_findSymbolTable(void)										
{																				
	ELF64_Hdr	*header;												
	uint64_t		sections_off;											
	uint16_t			sections_count;											
	uint8_t				*sections_raw;											
	ELF64_Shdr	*sections;												
																				
	header			= ctx.file.hdr##CLASS;										
	sections_off	= NM_ELF_FIELD(header->e_shoff);							
	sections_count	= NM_ELF_FIELD(header->footer.e_shnum);						
	sections_raw	= ctx.file.raw + sections_off;								
	sections		= (ELF64_Shdr *)sections_raw;						
																				
	ELF64_Shdr	*symtab			= NULL;									
	ELF64_Shdr	*symtab_str		= NULL;									
	uint32_t			symtab_link;											
																				
	for (uint16_t i = 0; i < sections_count; ++i)								
	{																			
		ELF64_Shdr	*current = &sections[i];		
		uint32_t			type = NM_ELF_FIELD(current->sh_type);				
																				
		if (type == SHT_SYMTAB)													
		{																		
			symtab = current;													
			symtab_link = NM_ELF_FIELD(current->sh_link);						
			symtab_str = &sections[symtab_link];								
			ctx.symtab_names_raw = (uint8_t *)symtab_str;						
			break ;																
		}																		
	}																			
																				
	if (!symtab)																
		nm_error("No symbol table found.", 3);									
																				
	uint64_t		symbols_off;											
																				
	symbols_off		= NM_ELF_FIELD(symtab->sh_offset);							
	ctx.nsym		= NM_ELF_FIELD(symtab->sh_size) / sizeof(ELF64_Sym);	
	ctx.symtab_raw	= ctx.file.raw + symbols_off;								
}		

void	nm##CLASS##_findSymbolTable(void)										\
{																				\
	ELF##CLASS##_Hdr	*header;												\
	uint##CLASS##_t		sections_off;											\
	uint16_t			sections_count;											\
	uint8_t				*sections_raw;											\
	ELF##CLASS##_Shdr	*sections;												\
																				\
	header			= ctx.file.hdr##CLASS;										\
	sections_off	= NM_ELF_FIELD(header->e_shoff);							\
	sections_count	= NM_ELF_FIELD(header->footer.e_shnum);						\
	sections_raw	= ctx.file.raw + sections_off;								\
	sections		= (ELF##CLASS##_Shdr *)sections_raw;						\
																				\
	ELF##CLASS##_Shdr	*symtab			= NULL;									\
	ELF##CLASS##_Shdr	*symtab_str		= NULL;									\
	uint32_t			symtab_link;											\
																				\
	for (uint16_t i = 0; i < sections_count; ++i)								\
	{																			\
		ELF##CLASS##_Shdr	*current = &sections[i];							\
		uint32_t			type = NM_ELF_FIELD(current->sh_type);				\
																				\
		if (type == SHT_SYMTAB)													\
		{																		\
			symtab = current;													\
			symtab_link = NM_ELF_FIELD(current->sh_link);						\
			symtab_str = &sections[symtab_link];								\
			ctx.symtab_names_raw = (uint8_t *)symtab_str;						\
			break ;																\
		}																		\
	}																			\
																				\
	if (!symtab)																\
		nm_error("No symbol table found.", 3);									\
																				\
	uint##CLASS##_t		symbols_off;											\
																				\
	symbols_off		= NM_ELF_FIELD(symtab->sh_offset);							\
	ctx.nsym		= NM_ELF_FIELD(symtab->sh_size) / sizeof(ELF##CLASS##_Sym);	\
	ctx.symtab_raw	= ctx.file.raw + symbols_off;								\
}																				\
